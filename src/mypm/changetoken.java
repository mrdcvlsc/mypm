/*
 * The MIT License
 *
 * Copyright 2022 mrdcvlsc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package mypm;

import java.security.SecureRandom;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Base64;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;

/**
 *
 * @author Occelot
 */
public class changetoken extends javax.swing.JFrame {

    public changetoken() {
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Windows".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(changetoken.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(changetoken.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(changetoken.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(changetoken.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        initComponents();
        this.setLocationRelativeTo(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        msg = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        op = new javax.swing.JPasswordField();
        jLabel3 = new javax.swing.JLabel();
        np = new javax.swing.JPasswordField();
        jLabel4 = new javax.swing.JLabel();
        rp = new javax.swing.JPasswordField();
        jButton1 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel1.setText("Password Change");

        msg.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        msg.setForeground(new java.awt.Color(255, 0, 0));
        msg.setText("-");

        jLabel2.setText("Old password:");

        jLabel3.setText("New password:");

        jLabel4.setText("Re-type new password");

        jButton1.setFont(new java.awt.Font("Segoe UI", 1, 14)); // NOI18N
        jButton1.setText("Change");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addGap(95, 95, 95)
                        .addComponent(jButton1))
                    .addComponent(msg)
                    .addComponent(jLabel2)
                    .addComponent(op)
                    .addComponent(jLabel3)
                    .addComponent(np)
                    .addComponent(jLabel4)
                    .addComponent(rp))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1)
                    .addComponent(jButton1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(msg)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(op, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(np, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(rp, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(45, 45, 45))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        
        msg.setText("Please wait...");
        
        String input_oldpassword = String.valueOf(op.getPassword());
        String input_newpassword = String.valueOf(np.getPassword());
        String input_retypepassword = String.valueOf(rp.getPassword());
        
        if(!input_newpassword.equals(input_retypepassword)){
            msg.setText(" New Password did not match...");
            return;
        }
        
        String DbOldHashWithSalt = "";
        
        String OldPass = "";
        String OldSalt = "";
        
        String NewPass = "";
        String NewSalt = "";
        
        try{
            Class.forName("org.sqlite.JDBC");
            Connection conn = DriverManager.getConnection("jdbc:sqlite:d/dt.db");
            Statement AuthQuery = conn.createStatement();
            ResultSet GetAuth = AuthQuery.executeQuery("SELECT * FROM `msr`");
            
            while(GetAuth.next()){
                DbOldHashWithSalt = GetAuth.getString("mpswd");
            }
                            
            OldPass = DbOldHashWithSalt.substring(0,128);
            OldSalt = DbOldHashWithSalt.substring(128,136);
            
            String AuthHash = javahash.SHA512Hash(OldSalt + input_oldpassword,12);
            
            if(!OldPass.equals(AuthHash)){
                msg.setText("Current password is incorrect...");
                return;
            }
            AuthQuery.close();
        }
        catch(SQLException e){
            msg.setText("Database Error, Database could be gone");
            e.printStackTrace();
            return;
        } catch (ClassNotFoundException ex) {
            msg.setText("Database Driver not found");
            Logger.getLogger(changetoken.class.getName()).log(Level.SEVERE, null, ex);
            return;
        }
        
        try{
            Class.forName("org.sqlite.JDBC");
            Connection conn = DriverManager.getConnection("jdbc:sqlite:d/dt.db");
         
            String UpdatePwQuery = "UPDATE `msr` SET mpswd=? WHERE mpswd=?";
            PreparedStatement UpdatePwExecute = conn.prepareStatement(UpdatePwQuery);
            
            NewSalt = AES128.keyToString(AES128.generateKey()).substring(0,8);
            NewPass = javahash.SHA512Hash((NewSalt + input_newpassword),12);
            
            UpdatePwExecute.setString(1, NewPass + NewSalt);
            UpdatePwExecute.setString(2, DbOldHashWithSalt);
            int changeSuccess = UpdatePwExecute.executeUpdate();
            UpdatePwExecute.close();
            
            if(changeSuccess==0)
            {
                msg.setText("Failed!");
                System.out.println("Password Change : Failed");
            }
            else
            {
                msg.setText("Success!");
                System.out.println("Password Change : Success");
                
                // update contents
                String algorithm = "AES/CBC/PKCS5Padding";
                
                String IvBufferPlatform;
                String IvBufferUser;
                String IvBufferPassword;
                
                SecretKey OldAesKey = AES128.generateKey(input_oldpassword, OldSalt);
                SecretKey NewAesKey = AES128.generateKey(input_newpassword, NewSalt);
                
                byte[] OldByteIV = new byte[16];
                byte[] NewByteIV = new byte[16];
                
                // retrieve old data
                ArrayList<String> Platforms = new ArrayList<>();
                ArrayList<String> Users = new ArrayList<>();
                ArrayList<String> Passwords = new ArrayList<>();
                
                int db_retrieved_items = 0;
                
                try{
                    Statement retrieveConn = conn.createStatement();
                    ResultSet retrieveGet = retrieveConn.executeQuery("SELECT * FROM `srstbl`");        
            
                    while(retrieveGet.next())
                    {
                        db_retrieved_items++;
                
                        String DbPlatform = retrieveGet.getString("pltfrm");
                        String DbUser = retrieveGet.getString("srs");
                        String DbPassword = retrieveGet.getString("psswrd");
                
                        IvBufferPlatform = DbPlatform.substring(0,24);
                        DbPlatform = DbPlatform.substring(24,DbPlatform.length());
                
                        IvBufferUser = DbUser.substring(0,24);
                        DbUser = DbUser.substring(24,DbUser.length());
                
                        IvBufferPassword = DbPassword.substring(0,24);
                        DbPassword = DbPassword.substring(24,DbPassword.length());
                
                        OldByteIV = Base64.getDecoder().decode(IvBufferPlatform);
                        Platforms.add(AES128.decrypt(algorithm, DbPlatform, OldAesKey, new IvParameterSpec(OldByteIV)));
                
                        OldByteIV = Base64.getDecoder().decode(IvBufferUser);
                        Users.add(AES128.decrypt(algorithm, DbUser, OldAesKey, new IvParameterSpec(OldByteIV)));
                
                        OldByteIV = Base64.getDecoder().decode(IvBufferPassword);
                        Passwords.add(AES128.decrypt(algorithm, DbPassword, OldAesKey, new IvParameterSpec(OldByteIV)));
                    }
                    System.out.println("--------------------------------------------");
                    System.out.println(""+db_retrieved_items+" items read from the database");
                    retrieveConn.close();
                } catch (Exception err) {
                    err.printStackTrace();
                    return;
                }
                
                // delete old data
                try{
                    String DeleteAllQuery = "DELETE FROM `srstbl`";
                    PreparedStatement DeleteAllExecute = conn.prepareStatement(DeleteAllQuery);
                    int db_deleted_items = DeleteAllExecute.executeUpdate();
                    System.out.println(""+db_deleted_items+" items deleted out of "+db_retrieved_items+" retrieved items");
                    DeleteAllExecute.close();
                } catch (Exception err) {
                    err.printStackTrace();
                    return;
                }
                
                // update with new data
                try{
                    String InsertQuery = "INSERT INTO `srstbl` VALUES(?,?,?)";
                    PreparedStatement InsertQueryExecute = conn.prepareStatement(InsertQuery);
                    
                    int db_updated_items = 0;
                    
                    for(int iu = 0; iu<Platforms.size(); ++iu) {
                        new SecureRandom().nextBytes(NewByteIV);
                        InsertQueryExecute.setString(1, AES128.ByteToString(NewByteIV) + AES128.encrypt(algorithm, Platforms.get(iu), NewAesKey, new IvParameterSpec(NewByteIV)));
                
                        new SecureRandom().nextBytes(NewByteIV);
                        InsertQueryExecute.setString(2, AES128.ByteToString(NewByteIV) + AES128.encrypt(algorithm, Users.get(iu), NewAesKey, new IvParameterSpec(NewByteIV)));
                
                        new SecureRandom().nextBytes(NewByteIV);
                        InsertQueryExecute.setString(3, AES128.ByteToString(NewByteIV) + AES128.encrypt(algorithm, Passwords.get(iu), NewAesKey, new IvParameterSpec(NewByteIV)));
                
                        db_updated_items += InsertQueryExecute.executeUpdate();
                    }
                    System.out.println(""+db_updated_items+" items updated out of "+db_retrieved_items+" retrieved items");
                    InsertQueryExecute.close();
                } catch (Exception err) {
                    err.printStackTrace();
                    return;
                }
            }
            this.setVisible(false);
        }
        catch(Exception e){
            msg.setText("Database Update Error");
            System.out.println(e);
            return;
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel msg;
    private javax.swing.JPasswordField np;
    private javax.swing.JPasswordField op;
    private javax.swing.JPasswordField rp;
    // End of variables declaration//GEN-END:variables
}
